// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Threading;
using System.Globalization;

namespace Microsoft.CorrelationVector
{
    /// <summary>
    /// This class represents version 2 of the cV, a lightweight vector for identifying and measuring
    /// causality.
    /// </summary>
    public sealed class CorrelationVectorV2 : CorrelationVector
    {
        internal new const byte MaxVectorLength = 127;
        internal const byte BaseLength = 22;

        internal readonly string BaseVector = null;

        private int extension = 0;

        private bool immutable = false;

        private static Random rng = new Random();

        /// <summary>
        /// This is the termination sign which should be used when vector length exceeds 
        /// the <see cref="MaxVectorLength"/>
        /// </summary>
        public const string TerminationSign = "!";

        /// <summary>
        /// Creates a new correlation vector by extending an existing value. This should be
        /// done at the entry point of an operation.
        /// </summary>
        /// <param name="correlationVector">
        /// Taken from the message header indicated by <see cref="HeaderName"/>.
        /// </param>
        /// <returns>A new correlation vector extended from the current vector.</returns>
        public new static CorrelationVectorV2 Extend(string correlationVector)
        {
            if (CorrelationVectorV2.IsImmutable(correlationVector))
            {
                return CorrelationVectorV2.Parse(correlationVector);
            }

            if (CorrelationVectorV2.ValidateCorrelationVectorDuringCreation)
            {
                CorrelationVectorV2.Validate(correlationVector);
            }

            if (CorrelationVectorV2.IsOversized(correlationVector, 0))
            {
                return CorrelationVectorV2.Parse(correlationVector + CorrelationVectorV2.TerminationSign);
            }

            return new CorrelationVectorV2(correlationVector, 0, false);
        }

        /// <summary>
        /// Creates a new correlation vector by applying the Spin operator to an existing value.
        /// This should be done at the entry point of an operation.
        /// </summary>
        /// <param name="correlationVector">
        /// Taken from the message header indicated by <see cref="HeaderName"/>.
        /// </param>
        /// <param name="parameters">
        /// The parameters to use when applying the Spin operator.
        /// </param>
        /// <returns>A new correlation vector extended from the current vector.</returns>
        public new static CorrelationVectorV2 Spin(string correlationVector, SpinParameters parameters)
        {
            if (CorrelationVectorV2.IsImmutable(correlationVector))
            {
                return CorrelationVectorV2.Parse(correlationVector);
            }

            if (CorrelationVectorV2.ValidateCorrelationVectorDuringCreation)
            {
                CorrelationVectorV2.Validate(correlationVector);
            }

            byte[] entropy = new byte[parameters.EntropyBytes];
            rng.NextBytes(entropy);

            ulong value = (ulong)(DateTime.UtcNow.Ticks >> parameters.TicksBitsToDrop);
            for (int i = 0; i < parameters.EntropyBytes; i++)
            {
                value = (value << 8) | Convert.ToUInt64(entropy[i]);
            }

            // Generate a bitmask and mask the lower TotalBits in the value.
            // The mask is generated by (1 << TotalBits) - 1. We need to handle the edge case
            // when shifting 64 bits, as it wraps around.
            value &= (parameters.TotalBits == 64 ? 0 : (ulong)1 << parameters.TotalBits) - 1;

            string s = unchecked((uint)value).ToString();
            if (parameters.TotalBits > 32)
            {
                s = string.Concat((value >> 32).ToString(), ".", s);
            }

            string baseVector = string.Concat(correlationVector, ".", s);
            if (CorrelationVectorV2.IsOversized(baseVector, 0))
            {
                return CorrelationVectorV2.Parse(correlationVector + CorrelationVectorV2.TerminationSign);
            }

            return new CorrelationVectorV2(baseVector, 0, false);
        }

        /// <summary>
        /// Creates a new correlation vector by parsing its string representation
        /// </summary>
        /// <param name="correlationVector">correlationVector</param>
        /// <returns>CorrelationVector</returns>
        public new static CorrelationVectorV2 Parse(string correlationVector)
        {
            if (!string.IsNullOrEmpty(correlationVector))
            {
                int p = correlationVector.LastIndexOf('.');
                bool immutable = CorrelationVectorV2.IsImmutable(correlationVector);
                if (p > 0)
                {
                    string extensionValue = immutable ? correlationVector.Substring(p + 1, correlationVector.Length - p - 1 - CorrelationVectorV2.TerminationSign.Length)
                        : correlationVector.Substring(p + 1);
                    int extension;
                    if (int.TryParse(extensionValue, out extension) && extension >= 0)
                    {
                        return new CorrelationVectorV2(correlationVector.Substring(0, p), extension,  immutable);
                    }
                }
            }

            return new CorrelationVectorV2();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CorrelationVectorV2"/> class. 
        /// This should only be called when no correlation
        /// vector was found in the message header.
        /// </summary>
        public CorrelationVectorV2()
            : this(CorrelationVectorV2.GetUniqueValue(), 0, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CorrelationVectorV2"/> class
        /// using the given <see cref="System.Guid"/> as the vector base.
        /// </summary>
        /// <param name="vectorBase">The <see cref="System.Guid"/> to use as a correlation
        /// vector base.</param>
        public CorrelationVectorV2(Guid vectorBase)
            : this(vectorBase.GetBaseFromGuid(BaseLength), 0, false)
        {
        }

        /// <summary>
        /// Gets the value of the correlation vector as a string.
        /// </summary>
        public override string Value
        {
            get
            {
                return string.Concat(this.BaseVector, ".", this.extension,
                    this.immutable ? CorrelationVectorV2.TerminationSign : string.Empty);
            }
        }

        /// <summary>
        /// Increments the current extension by one. Do this before passing the value to an
        /// outbound message header.
        /// </summary>
        /// <returns>
        /// The new value as a string that you can add to the outbound message header
        /// indicated by <see cref="HeaderName"/>.
        /// </returns>
        public override string Increment()
        {
            if (this.immutable)
            {
                return this.Value;
            }
            int snapshot = 0;
            int next = 0;
            do
            {
                snapshot = this.extension;
                if (snapshot == int.MaxValue)
                {
                    return this.Value;
                }
                next = snapshot + 1;
                if (CorrelationVectorV2.IsOversized(this.BaseVector, next))
                {
                    this.immutable = true;
                    return this.Value;
                }
            }
            while (snapshot != Interlocked.CompareExchange(ref this.extension, next, snapshot));
            return string.Concat(this.BaseVector, ".", next);
        }

        public override string Base
        {
            get
            {
                int firstDotLocation = Value.IndexOf('.');
                return Value.Substring(0, firstDotLocation);
            }
        }

        public override int Extension
        {
            get
            {
                return this.extension;
            }
        }

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        /// <returns>A string that represents the current object.</returns>
        public override string ToString()
        {
            return this.Value;
        }

        /// <summary>
        /// Determines whether two instances of the <see cref="CorrelationVectorV2"/> class
        /// are equal. 
        /// </summary>
        /// <param name="vector">
        /// The correlation vector you want to compare with the current correlation vector.
        /// </param>
        /// <returns>
        /// True if the specified correlation vector is equal to the current correlation
        /// vector; otherwise, false.
        /// </returns>
        public bool Equals(CorrelationVectorV2 vector)
        {
            return string.Equals(this.Value, vector.Value, StringComparison.Ordinal);
        }

        private CorrelationVectorV2(string baseVector, int extension, bool immutable)
        {
            this.BaseVector = baseVector;
            this.extension = extension;
            this.Version = CorrelationVectorVersion.V2;
            this.immutable = immutable || CorrelationVectorV2.IsOversized(baseVector, extension);
        }

        private static string GetUniqueValue()
        {
            return Guid.NewGuid().GetBaseFromGuid(BaseLength);
        }

        private static bool IsImmutable(string correlationVector)
        {
            return !string.IsNullOrEmpty(correlationVector) && correlationVector.EndsWith(CorrelationVectorV2.TerminationSign);
        }

        /// <summary>
        /// Checks if the cV will be too big if an extension is added to the base vector.
        /// </summary>
        /// <param name="baseVector"></param>
        /// <param name="extension"></param>
        /// <returns>True if new vector will be too large. False if there is no vector or the vector is the appropriate size.</returns>
        private static bool IsOversized(string baseVector, int extension)
        {
            if (!string.IsNullOrEmpty(baseVector))
            {
                int size = baseVector.Length + 1 +
                    (extension > 0 ? (int)Math.Log10(extension) : 0) + 1;
                return size > MaxVectorLength;
            }
            return false;
        }

        private static void Validate(string correlationVector)
        {
            byte maxVectorLength;
            byte baseLength;
            maxVectorLength = CorrelationVectorV2.MaxVectorLength;
            baseLength = CorrelationVectorV2.BaseLength;

            if (string.IsNullOrWhiteSpace(correlationVector) || correlationVector.Length > maxVectorLength)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                    "The {0} correlation vector can not be null or bigger than {1} characters", CorrelationVectorVersion.V2, maxVectorLength));
            }

            string[] parts = correlationVector.Split('.');

            if (parts.Length < 2 || parts[0].Length != baseLength)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Invalid correlation vector {0}. Invalid base value {1}", correlationVector, parts[0]));
            }

            for (int i = 1; i < parts.Length; i++)
            {
                int result;
                if (int.TryParse(parts[i], out result) == false || result < 0)
                {
                    throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Invalid correlation vector {0}. Invalid extension value {1}", correlationVector, parts[i]));
                }
            }
        }

        public override Tuple<string, string> Reset()
        {
            throw new InvalidOperationException("Reset is not supported in Correlation Vector V2");
        }
    }
}